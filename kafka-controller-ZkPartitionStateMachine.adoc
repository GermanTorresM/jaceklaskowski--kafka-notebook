== [[ZkPartitionStateMachine]] ZkPartitionStateMachine

`ZkPartitionStateMachine` is a concrete <<kafka-controller-PartitionStateMachine.adoc#, PartitionStateMachine>> to <<handleStateChanges, handle changes of the state of partitions>> (_partition state changes_).

`ZkPartitionStateMachine` uses <<controllerBrokerRequestBatch, ControllerBrokerRequestBatch>> to <<kafka-controller-AbstractControllerBrokerRequestBatch.adoc#sendRequestsToBrokers, propagate the changes to all brokers in a cluster>>.

`ZkPartitionStateMachine` is <<creating-instance, created>> exclusively for <<kafka-controller-KafkaController.adoc#partitionStateMachine, KafkaController>>.

[[logIdent]]
`ZkPartitionStateMachine` uses *[PartitionStateMachine controllerId=[brokerId]]* as the logging prefix (aka `logIdent`).

[[logging]]
[TIP]
====
Enable `ALL` logging levels for `kafka.controller.ZkPartitionStateMachine` logger to see what happens inside.

Add the following line to `config/log4j.properties`:

```
log4j.logger.kafka.controller.ZkPartitionStateMachine=ALL
```

Refer to <<kafka-logging.adoc#, Logging>>.
====

=== [[creating-instance]] Creating ZkPartitionStateMachine Instance

`ZkPartitionStateMachine` takes the following to be created:

* [[config]] <<kafka-server-KafkaConfig.adoc#, KafkaConfig>>
* [[stateChangeLogger]] `StateChangeLogger`
* [[controllerContext]] <<kafka-controller-ControllerContext.adoc#, ControllerContext>>
* [[zkClient]] <<kafka-zk-KafkaZkClient.adoc#, KafkaZkClient>>
* [[controllerBrokerRequestBatch]] <<kafka-controller-ControllerBrokerRequestBatch.adoc#, ControllerBrokerRequestBatch>>

=== [[handleStateChanges]] Handling State Changes of Partitions -- `handleStateChanges` Method

[source, scala]
----
handleStateChanges(
  partitions: Seq[TopicPartition],
  targetState: PartitionState,
  partitionLeaderElectionStrategyOpt: Option[PartitionLeaderElectionStrategy]
): Map[TopicPartition, Throwable]
----

NOTE: `handleStateChanges` is part of the <<kafka-controller-PartitionStateMachine.adoc#handleStateChanges, PartitionStateMachine Contract>> to handle state changes of partitions (_partition state changes_).

`handleStateChanges` requests the <<controllerBrokerRequestBatch, ControllerBrokerRequestBatch>> to <<kafka-controller-AbstractControllerBrokerRequestBatch.adoc#newBatch, prepare a new batch>>.

`handleStateChanges` <<doHandleStateChanges, doHandleStateChanges>> (that may give some errors that are returned in the end).

In the end, `handleStateChanges` requests the <<controllerBrokerRequestBatch, ControllerBrokerRequestBatch>> to <<kafka-controller-AbstractControllerBrokerRequestBatch.adoc#sendRequestsToBrokers, send controller requests to brokers>> and returns the errors.

In case of `ControllerMovedException`, `handleStateChanges` prints out the following ERROR message to the logs:

```
Controller moved to another broker when moving some partitions to [targetState] state
```

In case of any other error (`Throwable`), `handleStateChanges` prints out the following ERROR message to the logs:

```
Error while moving some partitions to [targetState] state
```

=== [[doHandleStateChanges]] `doHandleStateChanges` Internal Method

[source, scala]
----
doHandleStateChanges(
  partitions: Seq[TopicPartition],
  targetState: PartitionState,
  partitionLeaderElectionStrategyOpt: Option[PartitionLeaderElectionStrategy]
): Map[TopicPartition, Throwable]
----

For every partition (in `partitions`), `doHandleStateChanges` requests the <<controllerContext, ControllerContext>> to <<kafka-controller-ControllerContext.adoc#putPartitionStateIfNotExists, putPartitionStateIfNotExists>> to `NonExistentPartition`.

`doHandleStateChanges` requests the <<controllerContext, ControllerContext>> to <<kafka-controller-ControllerContext.adoc#checkValidPartitionStateChange, checkValidPartitionStateChange>> (that gives valid and invalid partitions).

For every invalid partition, `doHandleStateChanges` <<logInvalidTransition, logInvalidTransition>>.

`doHandleStateChanges` branches off per the target state: <<doHandleStateChanges-NewPartition, NewPartition>>, <<doHandleStateChanges-OnlinePartition, OnlinePartition>>, <<doHandleStateChanges-OfflinePartition, OfflinePartition>>, and <<NonExistentPartition, NonExistentPartition>>.

NOTE: `doHandleStateChanges` is used exclusively when `ZkPartitionStateMachine` is requested to <<handleStateChanges, handle partition state changes>>.

==== [[doHandleStateChanges-NewPartition]] NewPartition

For `NewPartition` target state, `doHandleStateChanges` goes over the valid partitions and for every partition prints out the following TRACE message to the logs and requests the <<controllerContext, ControllerContext>> to <<kafka-controller-ControllerContext.adoc#putPartitionState, putPartitionState>> to `NewPartition` state.

```
Changed partition [partition] state from [state] to NewPartition with assigned replicas [partitionReplicaAssignment]
```

==== [[doHandleStateChanges-OnlinePartition]] OnlinePartition

For `OnlinePartition` target state, `doHandleStateChanges`...FIXME

==== [[doHandleStateChanges-OfflinePartition]] OfflinePartition

For `OfflinePartition` target state, `doHandleStateChanges` goes over the valid partitions and for every partition prints out the following TRACE message to the logs and requests the <<controllerContext, ControllerContext>> to <<kafka-controller-ControllerContext.adoc#putPartitionState, putPartitionState>> to `OfflinePartition` state.

```
Changed partition [partition] state from [state] to OfflinePartition
```

==== [[doHandleStateChanges-NonExistentPartition]] NonExistentPartition

For `NonExistentPartition` target state, `doHandleStateChanges` goes over the valid partitions and for every partition prints out the following TRACE message to the logs and requests the <<controllerContext, ControllerContext>> to <<kafka-controller-ControllerContext.adoc#putPartitionState, putPartitionState>> to `NonExistentPartition` state.

```
Changed partition [partition] state from [state] to NonExistentPartition
```

=== [[initializeLeaderAndIsrForPartitions]] `initializeLeaderAndIsrForPartitions` Internal Method

[source, scala]
----
initializeLeaderAndIsrForPartitions(
  partitions: Seq[TopicPartition]): Seq[TopicPartition]
----

`initializeLeaderAndIsrForPartitions`...FIXME

NOTE: `initializeLeaderAndIsrForPartitions` is used exclusively when `ZkPartitionStateMachine` is requested to <<doHandleStateChanges, doHandleStateChanges>>.

=== [[electLeaderForPartitions]] `electLeaderForPartitions` Internal Method

[source, scala]
----
electLeaderForPartitions(
  partitions: Seq[TopicPartition],
  partitionLeaderElectionStrategy: PartitionLeaderElectionStrategy
): (Seq[TopicPartition], Map[TopicPartition, Throwable])
----

`electLeaderForPartitions`...FIXME

NOTE: `electLeaderForPartitions` is used exclusively when `ZkPartitionStateMachine` is requested to <<doHandleStateChanges, doHandleStateChanges>>.

=== [[doElectLeaderForPartitions]] `doElectLeaderForPartitions` Internal Method

[source, scala]
----
doElectLeaderForPartitions(
  partitions: Seq[TopicPartition],
  partitionLeaderElectionStrategy: PartitionLeaderElectionStrategy
): (Seq[TopicPartition], Seq[TopicPartition], Map[TopicPartition, Exception])
----

`doElectLeaderForPartitions`...FIXME

NOTE: `doElectLeaderForPartitions` is used exclusively when `ZkPartitionStateMachine` is requested to <<electLeaderForPartitions, electLeaderForPartitions>>.

=== [[collectUncleanLeaderElectionState]] `collectUncleanLeaderElectionState` Internal Method

[source, scala]
----
collectUncleanLeaderElectionState(
  leaderIsrAndControllerEpochs: Seq[(TopicPartition, LeaderIsrAndControllerEpoch)]
): Seq[(TopicPartition, Option[LeaderIsrAndControllerEpoch], Boolean)]
----

`collectUncleanLeaderElectionState`...FIXME

NOTE: `collectUncleanLeaderElectionState` is used exclusively when `ZkPartitionStateMachine` is requested to <<doElectLeaderForPartitions, doElectLeaderForPartitions>> (for <<kafka-controller-PartitionStateMachine.adoc#OfflinePartitionLeaderElectionStrategy, OfflinePartitionLeaderElectionStrategy>>).

=== [[logInvalidTransition]] `logInvalidTransition` Internal Method

[source, scala]
----
logInvalidTransition(
  partition: TopicPartition,
  targetState: PartitionState): Unit
----

`logInvalidTransition`...FIXME

NOTE: `logInvalidTransition` is used exclusively when `ZkPartitionStateMachine` is requested to <<doHandleStateChanges, doHandleStateChanges>> (for invalid partitions).

=== [[logFailedStateChange]] Printing Out ERROR Message to Logs -- `logFailedStateChange` Internal Method

[source, scala]
----
logFailedStateChange(
  partition: TopicPartition,
  currState: PartitionState,
  targetState: PartitionState,
  code: Code): Unit // <1>
logFailedStateChange(
  partition: TopicPartition,
  currState: PartitionState,
  targetState: PartitionState,
  t: Throwable): Unit
----
<1> Converts the code to a `KeeperException`

`logFailedStateChange` simply prints out the following ERROR message to the logs:

[options="wrap"]
----
Controller [controllerId] epoch [epoch] failed to change state for partition [partition] from [currState] to [targetState]
----

NOTE: `logFailedStateChange` is used when `ZkPartitionStateMachine` is requested to <<initializeLeaderAndIsrForPartitions, initializeLeaderAndIsrForPartitions>>, <<electLeaderForPartitions, electLeaderForPartitions>>, <<collectUncleanLeaderElectionState, collectUncleanLeaderElectionState>>, and <<logInvalidTransition, logInvalidTransition>>.

=== [[partitionState]] `partitionState` Internal Method

[source, scala]
----
partitionState(
  partition: TopicPartition): PartitionState
----

`partitionState`...FIXME

NOTE: `partitionState` is used when...FIXME
