== [[KafkaController]] KafkaController

`KafkaController` is a Kafka service that is part of every Kafka broker, but only one `KafkaController` is <<isActive, active>> (_elected_) among all Kafka brokers in a Kafka cluster.

The process of choosing the KafkaController among brokers is <<elect, Controller Election>>.

`KafkaController` is a Kafka service responsible for:

* <<topicDeletionListener, topic deletion>>
* ...FIXME

Quoting https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Controller+Internals[Kafka Controller Internals]:

> In a Kafka cluster, one of the brokers serves as the controller, which is responsible for managing the states of partitions and replicas and for performing administrative tasks like reassigning partitions.

`KafkaController` is <<creating-instance, created>> and immediately <<startup, started>> when `KafkaServer` is requested to <<kafka-KafkaServer.adoc#startup, start up>>.

.KafkaController
image::images/KafkaController.png[align="center"]

`KafkaController` uses the <<zkClient, KafkaZkClient>> for the following:

* Creating the <<topicDeletionManager, TopicDeletionManager>>, the <<replicaStateMachine, ReplicaStateMachine>> and the <<partitionStateMachine, PartitionStateMachine>>

* Registering a `StateChangeHandler` when requested to <<startup, startup>>

* <<updateBrokerInfo, Updating BrokerInfo>>

* <<onControllerFailover, onControllerFailover>>

* <<onControllerResignation, onControllerResignation>>

* <<registerBrokerModificationsHandler, registerBrokerModificationsHandler>>

* <<unregisterBrokerModificationsHandler, unregisterBrokerModificationsHandler>>

* <<maybeTriggerPartitionReassignment, maybeTriggerPartitionReassignment>>

* <<incrementControllerEpoch, incrementControllerEpoch>>

* <<initializeControllerContext, initializeControllerContext>>

* <<fetchPendingPreferredReplicaElections, fetchPendingPreferredReplicaElections>>

* <<initializePartitionReassignment, initializePartitionReassignment>>

* <<fetchTopicDeletionsInProgress, fetchTopicDeletionsInProgress>>

* <<updateLeaderAndIsrCache, updateLeaderAndIsrCache>>

* <<areReplicasInIsr, areReplicasInIsr>>

* <<updateAssignedReplicasForPartition, updateAssignedReplicasForPartition>>

* <<registerPartitionModificationsHandlers, registerPartitionModificationsHandlers>>

* <<unregisterPartitionModificationsHandlers, unregisterPartitionModificationsHandlers>>

* <<unregisterPartitionReassignmentIsrChangeHandlers, unregisterPartitionReassignmentIsrChangeHandlers>>

* <<readControllerEpochFromZooKeeper, readControllerEpochFromZooKeeper>>

* <<removePartitionsFromReassignedPartitions, removePartitionsFromReassignedPartitions>>

* <<removePartitionsFromPreferredReplicaElection, removePartitionsFromPreferredReplicaElection>>

* <<updateLeaderEpoch, updateLeaderEpoch>>

* Processing <<Startup, Startup>>, <<BrokerChange, BrokerChange>>, <<BrokerModifications, BrokerModifications>>, <<TopicChange, TopicChange>>, <<LogDirEventNotification, LogDirEventNotification>>, <<PartitionModifications, PartitionModifications>>, <<TopicDeletion, TopicDeletion>>, <<PartitionReassignment, PartitionReassignment>>, <<PartitionReassignmentIsrChange, PartitionReassignmentIsrChange>>, <<IsrChangeNotification, IsrChangeNotification>>, <<PreferredReplicaLeaderElection, PreferredReplicaLeaderElection>>, <<ControllerChange, ControllerChange>>, <<Reelect, Reelect>> and <<RegisterBrokerAndReelect, RegisterBrokerAndReelect>> controller events

* <<triggerControllerMove, triggerControllerMove>>

* <<elect, elect>>

`KafkaController` uses <<listeners, listeners>> as a notification system to monitor znodes in Zookeeper and react accordingly.

`KafkaController` emulates a state machine using <<controller-events, controller events>>.

[[controller-events]]
.KafkaController's Controller Events
[cols="1m,1,2",options="header",width="100%"]
|===
| Event
| ControllerState
| process Handler

| [[BrokerChange]] BrokerChange
| `BrokerChange`
|

a| [[ControllerChange]] ControllerChange

* `newControllerId`: Int

| `ControllerChange`
a|

1. Assigns the <<getControllerID, current controller ID>> as the input `newControllerId`
1. (only when the broker is no longer an <<isActive, active controller>>) <<onControllerResignation, Resigns as the active controller>>

NOTE:  Similar to <<Reelect, Reelect>> event with the only difference that it does *not* trigger <<elect, election>>

a| [[ControlledShutdown]] ControlledShutdown

* `ID`

* `controlledShutdownCallback`: Try[Set[TopicAndPartition]] => Unit

| `ControlledShutdown`
|

| [[IsrChangeNotification]] IsrChangeNotification
|
|

| [[PartitionReassignment]] PartitionReassignment
|
|

| [[PreferredReplicaLeaderElection]] PreferredReplicaLeaderElection
|
|

| [[Reelect]] Reelect
| `ControllerChange`
a|

1. Assigns the <<getControllerID, current controller ID>> as <<activeControllerId, activeControllerId>>
1. (only when the broker is no longer an <<isActive, active controller>>) <<onControllerResignation, Resigns as the active controller>>
1. <<elect, elect>>

| [[Startup]] Startup
| `ControllerChange`
a|

1. <<registerSessionExpirationListener, registerSessionExpirationListener>>
1. <<registerControllerChangeListener, registerControllerChangeListener>>
1. <<elect, elect>>

| [[TopicChange]] TopicChange
|
|
|===

[[logIdent]]
`logIdent` is *[Controller id=[brokerId]]*.

[[internal-registries]]
.KafkaController's Internal Properties (e.g. Registries and Counters)
[cols="1m,2",options="header",width="100%"]
|===
| Name
| Description

| activeControllerId
a| [[activeControllerId]] The ID of the active `KafkaController`

* Initialized to `-1`

| controllerChangeHandler
a| [[controllerChangeHandler]] A `ZNodeChangeHandler` (for the `KafkaController` and the <<eventManager, ControllerEventManager>>) that listens to change events on `/controller` znode.

`controllerChangeHandler` <<kafka-ControllerEventManager.adoc#put, emits controller events>> as follows:

* `ControllerChange` when the znode is created or the znode data changed

* `Reelect` when the znode is deleted

| controllerContext
| [[controllerContext]]

| eventManager
| [[eventManager]] link:kafka-ControllerEventManager.adoc[ControllerEventManager] for `controllerContext.stats.rateAndTimeMetrics` and updateMetrics listener

| kafkaScheduler
| [[kafkaScheduler]] <<kafka-KafkaScheduler.adoc#, KafkaScheduler>> with 1 daemon thread with *kafka-scheduler* prefix

| partitionStateMachine
| [[partitionStateMachine]] link:kafka-PartitionStateMachine.adoc[PartitionStateMachine]

| replicaStateMachine
| [[replicaStateMachine]] link:kafka-ReplicaStateMachine.adoc[ReplicaStateMachine]

| stateChangeLogger
| [[stateChangeLogger]] `StateChangeLogger` with the <<brokerId, broker ID>> and `inControllerContext` flag enabled

| tokenCleanScheduler
| [[tokenCleanScheduler]] <<kafka-KafkaScheduler.adoc#, KafkaScheduler>> with 1 daemon thread with *delegation-token-cleaner* prefix

| topicDeletionManager
| [[topicDeletionManager]] <<kafka-TopicDeletionManager.adoc#, TopicDeletionManager>>
|===

[[listeners]]
.KafkaController's Listeners
[cols="1,2",options="header",width="100%"]
|===
| Listener
| Description

| [[brokerChangeListener]] `brokerChangeListener`
| `BrokerChangeListener` for this `KafkaController` and <<eventManager, eventManager>>

| [[isrChangeNotificationListener]] `isrChangeNotificationListener`
| `IsrChangeNotificationListener` for this `KafkaController` and <<eventManager, eventManager>>

Registered in <<registerIsrChangeNotificationListener, registerIsrChangeNotificationListener>> when `KafkaController` does <<onControllerFailover, onControllerFailover>>.

De-registered in <<deregisterIsrChangeNotificationListener, deregisterIsrChangeNotificationListener>> when `KafkaController` <<onControllerResignation, resigns as the active controller>>.

| [[logDirEventNotificationListener]] `logDirEventNotificationListener`
| `LogDirEventNotificationListener`

| [[partitionModificationsListeners]] `partitionModificationsListeners`
| `PartitionModificationsListener` by name

| [[partitionReassignmentListener]] `partitionReassignmentListener`
| `PartitionReassignmentListener` for this `KafkaController` and <<eventManager, ControllerEventManager>>

| [[preferredReplicaElectionListener]] `preferredReplicaElectionListener`
| `PreferredReplicaElectionListener` for this `KafkaController` and <<eventManager, ControllerEventManager>>

| [[topicDeletionListener]] `topicDeletionListener`
| `TopicDeletionListener` (for this `KafkaController` and <<eventManager, ControllerEventManager>>)

Registered in <<registerTopicDeletionListener, registerTopicDeletionListener>> when `KafkaController` does <<onControllerFailover, onControllerFailover>>.

De-registered in <<deregisterTopicDeletionListener, deregisterTopicDeletionListener>> when `KafkaController` <<onControllerResignation, resigns as the active controller>>.
|===

[[logging]]
[TIP]
====
Enable `WARN`, `INFO` or `DEBUG` logging levels for `kafka.controller.KafkaController` logger to see what happens inside.

Add the following line to `config/log4j.properties`:

```
log4j.logger.kafka.controller.KafkaController=DEBUG
```

Refer to link:kafka-logging.adoc[Logging].

---
Please note that Kafka comes with a preconfigured `kafka.controller` logger in `config/log4j.properties`:

```
log4j.appender.controllerAppender=org.apache.log4j.DailyRollingFileAppender
log4j.appender.controllerAppender.DatePattern='.'yyyy-MM-dd-HH
log4j.appender.controllerAppender.File=${kafka.logs.dir}/controller.log
log4j.appender.controllerAppender.layout=org.apache.log4j.PatternLayout
log4j.appender.controllerAppender.layout.ConversionPattern=[%d] %p %m (%c)%n

log4j.logger.kafka.controller=TRACE, controllerAppender
log4j.additivity.kafka.controller=false
```

That means that the logs of `KafkaController` go to `logs/controller.log` file at `TRACE` logging level and are not added to the main logs (per `log4j.additivity` being off).
====

=== [[initiateReassignReplicasForTopicPartition]] `initiateReassignReplicasForTopicPartition` Method

[source, scala]
----
initiateReassignReplicasForTopicPartition
----

`initiateReassignReplicasForTopicPartition`...FIXME

NOTE: `initiateReassignReplicasForTopicPartition` is used when...FIXME

=== [[deregisterPartitionReassignmentIsrChangeListeners]] `deregisterPartitionReassignmentIsrChangeListeners` Method

[source, scala]
----
deregisterPartitionReassignmentIsrChangeListeners
----

`deregisterPartitionReassignmentIsrChangeListeners`...FIXME

NOTE: `deregisterPartitionReassignmentIsrChangeListeners` is used when...FIXME

=== [[resetControllerContext]] `resetControllerContext` Method

[source, scala]
----
resetControllerContext
----

`resetControllerContext`...FIXME

NOTE: `resetControllerContext` is used when...FIXME

=== [[deregisterBrokerChangeListener]] `deregisterBrokerChangeListener` Method

[source, scala]
----
deregisterBrokerChangeListener
----

`deregisterBrokerChangeListener`...FIXME

NOTE: `deregisterBrokerChangeListener` is used when...FIXME

=== [[deregisterTopicChangeListener]] `deregisterTopicChangeListener` Method

[source, scala]
----
deregisterTopicChangeListener
----

`deregisterTopicChangeListener`...FIXME

NOTE: `deregisterTopicChangeListener` is used when...FIXME

=== [[onControllerResignation]] Resigning As Active Controller -- `onControllerResignation` Method

[source, scala]
----
onControllerResignation(): Unit
----

`onControllerResignation` starts by printing out the following DEBUG message to the logs:

```
Resigning
```

`onControllerResignation` unsubscribes from intercepting Zookeeper events for the following znodes in order:

1. <<deregisterIsrChangeNotificationListener, Child changes to /isr_change_notification znode>>

1. <<deregisterPartitionReassignmentListener, Data changes to /admin/reassign_partitions znode>>

1. <<deregisterPreferredReplicaElectionListener, Data changes to /admin/preferred_replica_election znode>>

1. <<deregisterLogDirEventNotificationListener, Child changes to /log_dir_event_notification znode>>

`onControllerResignation` requests <<topicDeletionManager, TopicDeletionManager>> to link:kafka-TopicDeletionManager.adoc#reset[reset].

`onControllerResignation` requests <<kafkaScheduler, KafkaScheduler>> to link:kafka-KafkaScheduler.adoc#shutdown[shutdown].

`onControllerResignation` resets the following internal counters:

* <<offlinePartitionCount, offlinePartitionCount>>
* <<preferredReplicaImbalanceCount, preferredReplicaImbalanceCount>>
* <<globalTopicCount, globalTopicCount>>
* <<globalPartitionCount, globalPartitionCount>>

`onControllerResignation` <<deregisterPartitionReassignmentIsrChangeListeners, deregisterPartitionReassignmentIsrChangeListeners>>.

`onControllerResignation` requests <<partitionStateMachine, PartitionStateMachine>> to link:kafka-PartitionStateMachine.adoc#shutdown[shutdown].

`onControllerResignation` <<deregisterTopicChangeListener, deregisterTopicChangeListener>>.

`onControllerResignation` <<deregisterPartitionModificationsListener, deregisterPartitionModificationsListener>> every listener in <<partitionModificationsListeners, partitionModificationsListeners>>.

`onControllerResignation` <<deregisterTopicDeletionListener, deregisterTopicDeletionListener>>.

`onControllerResignation` requests <<replicaStateMachine, ReplicaStateMachine>> to link:kafka-ReplicaStateMachine.adoc#shutdown[shutdown].

`onControllerResignation` <<deregisterBrokerChangeListener, deregisterBrokerChangeListener>>.

`onControllerResignation` <<resetControllerContext, resetControllerContext>>.

In the end, `onControllerResignation` prints out the following DEBUG message to the logs:

```
Resigned
```

[NOTE]
====
`onControllerResignation` is used when:

* `ControllerEventThread` is requested to <<kafka-ControllerEventThread.adoc#doWork, process controller events>>, i.e. <<ControllerChange, ControllerChange>> and <<Reelect, Reelect>>

* <<triggerControllerMove, triggerControllerMove>>

* `KafkaController` is requested to <<shutdown, shut down>>
====

=== [[deregisterIsrChangeNotificationListener]] Unsubscribing from Child Changes to /isr_change_notification ZNode -- `deregisterIsrChangeNotificationListener` Internal Method

[source, scala]
----
deregisterIsrChangeNotificationListener(): Unit
----

`deregisterIsrChangeNotificationListener` prints out the following DEBUG message to the logs:

```
De-registering IsrChangeNotificationListener
```

`deregisterIsrChangeNotificationListener` requests <<zkUtils, ZkUtils>> to link:kafka-ZkUtils.adoc#unsubscribeChildChanges[unsubscribe from intercepting changes] to `/isr_change_notification` znode with <<isrChangeNotificationListener, IsrChangeNotificationListener>>.

NOTE: `deregisterIsrChangeNotificationListener` is used exclusively when `KafkaController` <<onControllerResignation, resigns as the active controller>>.

=== [[deregisterLogDirEventNotificationListener]] Unsubscribing from Child Changes to /log_dir_event_notification ZNode -- `deregisterLogDirEventNotificationListener` Internal Method

[source, scala]
----
deregisterLogDirEventNotificationListener(): Unit
----

`deregisterLogDirEventNotificationListener` prints out the following DEBUG message to the logs:

```
De-registering logDirEventNotificationListener
```

`deregisterLogDirEventNotificationListener` requests <<zkUtils, ZkUtils>> to link:kafka-ZkUtils.adoc#unsubscribeChildChanges[unsubscribe from intercepting changes] to `/log_dir_event_notification` znode with <<logDirEventNotificationListener, LogDirEventNotificationListener>>.

NOTE: `deregisterLogDirEventNotificationListener` is used exclusively when `KafkaController` <<onControllerResignation, resigns as the active controller>>.

=== [[deregisterPreferredReplicaElectionListener]] Unsubscribing from Data Changes to /admin/preferred_replica_election ZNode -- `deregisterPreferredReplicaElectionListener` Method

[source, scala]
----
deregisterPreferredReplicaElectionListener(): Unit
----

`deregisterPreferredReplicaElectionListener` requests <<zkUtils, ZkUtils>> to link:kafka-ZkUtils.adoc#unsubscribeDataChanges[unsubscribe from intercepting data changes] to `/admin/preferred_replica_election` znode with <<preferredReplicaElectionListener, PreferredReplicaElectionListener>>.

NOTE: `deregisterPreferredReplicaElectionListener` is used exclusively when `KafkaController` <<onControllerResignation, resigns as the active controller>>.

=== [[deregisterPartitionReassignmentListener]] Unsubscribing from Data Changes to /admin/reassign_partitions ZNode -- `deregisterPartitionReassignmentListener` Method

[source, scala]
----
deregisterPartitionReassignmentListener(): Unit
----

`deregisterPartitionReassignmentListener` requests <<zkUtils, ZkUtils>> to link:kafka-ZkUtils.adoc#unsubscribeDataChanges[unsubscribe from intercepting data changes] to `/admin/reassign_partitions` znode with <<partitionReassignmentListener, PartitionReassignmentListener>>.

NOTE: `deregisterPartitionReassignmentListener` is used exclusively when `KafkaController` <<onControllerResignation, resigns as the active controller>>.

=== [[triggerControllerMove]] `triggerControllerMove` Internal Method

[source, scala]
----
triggerControllerMove(): Unit
----

`triggerControllerMove`...FIXME

[NOTE]
====
`triggerControllerMove` is used when:

1. `KafkaController` <<handleIllegalState, handleIllegalState>>

1. `KafkaController` caught an exception while <<elect, electing or becoming a controller>>
====

=== [[handleIllegalState]] `handleIllegalState` Internal Method

[source, scala]
----
handleIllegalState(e: IllegalStateException): Nothing
----

`handleIllegalState`...FIXME

NOTE: `handleIllegalState` is used when `KafkaController` catches a `IllegalStateException` in <<updateLeaderEpochAndSendRequest, updateLeaderEpochAndSendRequest>>, <<sendUpdateMetadataRequest, sendUpdateMetadataRequest>> and <<ControlledShutdown, ControlledShutdown>> event.

=== [[sendUpdateMetadataRequest]] `sendUpdateMetadataRequest` Method

[source, scala]
----
sendUpdateMetadataRequest(): Unit
----

`sendUpdateMetadataRequest`...FIXME

[NOTE]
====
`sendUpdateMetadataRequest` is used when:

* `KafkaController` is requested to <<onControllerFailover, onControllerFailover>>, <<onBrokerStartup, onBrokerStartup>>, <<onBrokerUpdate, onBrokerUpdate>>, <<onReplicasBecomeOffline, onReplicasBecomeOffline>>, <<onPartitionReassignment, onPartitionReassignment>>, <<processUpdateNotifications, processUpdateNotifications>>

* `TopicDeletionManager` is requested to <<kafka-TopicDeletionManager.adoc#onTopicDeletion, onTopicDeletion>>
====

=== [[updateLeaderEpochAndSendRequest]] `updateLeaderEpochAndSendRequest` Internal Method

[source, scala]
----
updateLeaderEpochAndSendRequest(): Unit
----

`updateLeaderEpochAndSendRequest`...FIXME

NOTE: `updateLeaderEpochAndSendRequest` is used when `KafkaController` is requested to <<onPartitionReassignment, onPartitionReassignment>> and <<moveReassignedPartitionLeaderIfRequired, moveReassignedPartitionLeaderIfRequired>>.

=== [[shutdown]] `shutdown` Method

[source, scala]
----
shutdown(): Unit
----

`shutdown`...FIXME

NOTE: `shutdown` is used exclusively when `KafkaServer` is requested to <<kafka-KafkaServer.adoc#shutdown, shutdown>>.

=== [[updateMetrics]] `updateMetrics` Internal Method

CAUTION: FIXME

=== [[onBrokerStartup]] `onBrokerStartup` Method

[source, scala]
----
onBrokerStartup(newBrokers: Seq[Int]): Unit
----

`onBrokerStartup`...FIXME

NOTE: `onBrokerStartup` is used exclusively when `KafkaController` processes `BrokerChange` controller event.

=== [[elect]] Controller Election -- `elect` Method

[source, scala]
----
elect(): Unit
----

`elect` requests the <<zkClient, KafkaZkClient>> for the <<kafka-zk-KafkaZkClient.adoc#getControllerId, active controller ID>>.

`elect` stops the controller election if there is an active controller ID available and prints out the following DEBUG message to the logs:

```
Broker [activeControllerId] has been elected as the controller, so stopping the election process.
```

Otherwise, `elect` requests the <<zkClient, KafkaZkClient>> to <<checkedEphemeralCreate, create an ephemeral znode>> at `/controller` path with the znode data in JSON:

```
{"version":1,"brokerid":[brokerId],"timestamp":[timestamp]}
```

NOTE: `elect` always uses `1` for the version.

==== Controller Elected

If successful, `elect` prints out the following INFO message to the logs and records the current broker ID as the <<activeControllerId, activeControllerId>>.

```
[brokerId] successfully elected as the controller
```

In the end, `elect` does <<onControllerFailover, onControllerFailover>>.

==== Controller Has Already Been Elected (NodeExistsException)

If unsuccessful (and a `NodeExistsException` was reported), `elect` requests the <<zkClient, KafkaZkClient>> for the <<kafka-zk-KafkaZkClient.adoc#getControllerId, active controller ID>>.

`elect` then prints out the following DEBUG message to the logs:

```
Broker [activeControllerId] was elected as controller instead of broker [brokerId]
```

If however the active controller ID is still unavailable, `elect` prints out the following WARN message to the logs:

```
A controller has been elected but just resigned, this will result in another round of election
```

==== Other Errors (Throwable)

If unsuccessful (and a `Throwable` was reported), `elect` prints out the following ERROR message to the logs and does <<triggerControllerMove, triggerControllerMove>>:

```
Error while electing or becoming controller on broker [brokerId]
```

NOTE: `elect` is used when `ControllerEventThread` is requested to process <<kafka-ControllerEvent.adoc#Startup, Startup>> and <<kafka-ControllerEvent.adoc#Reelect, Reelect>> events (while <<kafka-ControllerEventThread.adoc#doWork, processing controller events>>).

=== [[isActive]] Is KafkaController The Active Controller? -- `isActive` Method

[source, scala]
----
isActive: Boolean
----

`isActive` flag says whether the current broker (by the ID) is the active controller (given the <<activeControllerId, activeControllerId>>).

NOTE: `isActive` is on (`true`) after the `KafkaController` of a Kafka broker has been <<elect, elected>>.

[NOTE]
====
`isActive` is used (as a valve to stop processing early) when:

* `ControllerEventThread` is requested to <<kafka-ControllerEventThread.adoc#doWork, process controller events>> (that should only be processed on the active controller, e.g. `AutoPreferredReplicaLeaderElection`, `UncleanLeaderElectionEnable`, `ControlledShutdown`, `LeaderAndIsrResponseReceived`, `TopicDeletionStopReplicaResponseReceived`, `BrokerChange`, `BrokerModifications`, `TopicChange`)

* `KafkaController` is requested to <<updateMetrics, updateMetrics>>

* `KafkaApis` is requested to <<kafka-KafkaApis.adoc#handleCreateTopicsRequest, handleCreateTopicsRequest>>, <<kafka-KafkaApis.adoc#handleCreatePartitionsRequest, handleCreatePartitionsRequest>> and <<kafka-KafkaApis.adoc#handleDeleteTopicsRequest, handleDeleteTopicsRequest>>
====

=== [[registerIsrChangeNotificationListener]] `registerIsrChangeNotificationListener` Internal Method

[source, scala]
----
registerIsrChangeNotificationListener(): Option[Seq[String]]
----

`registerIsrChangeNotificationListener`...FIXME

NOTE: `registerIsrChangeNotificationListener` is used when...FIXME

=== [[deregisterIsrChangeNotificationListener]] `deregisterIsrChangeNotificationListener` Internal Method

[source, scala]
----
deregisterIsrChangeNotificationListener(): Unit
----

`deregisterIsrChangeNotificationListener`...FIXME

NOTE: `deregisterIsrChangeNotificationListener` is used when...FIXME

=== [[creating-instance]] Creating KafkaController Instance

`KafkaController` takes the following when created:

* [[config]] <<kafka-KafkaConfig.adoc#, KafkaConfig>>
* [[zkClient]] <<kafka-zk-KafkaZkClient.adoc#, KafkaZkClient>>
* [[time]] `Time`
* [[metrics]] <<kafka-Metrics.adoc#, Metrics>>
* [[initialBrokerInfo]] `BrokerInfo`
* [[tokenManager]] <<kafka-server-DelegationTokenManager.adoc#, DelegationTokenManager>>
* [[threadNamePrefix]] Thread name prefix (default: undefined)

`KafkaController` initializes the <<internal-registries, internal registries and counters>>.

=== [[startup]] Starting Up -- `startup` Method

[source, scala]
----
startup(): Unit
----

`startup` requests the <<zkClient, KafkaZkClient>> to <<kafka-zk-KafkaZkClient.adoc#registerStateChangeHandler, register a StateChangeHandler>> (under the name *controller-state-change-handler*) that is does the following:

* On `afterInitializingSession`, the `StateChangeHandler` simply puts `RegisterBrokerAndReelect` event on the event queue of the <<eventManager, ControllerEventManager>>

* On `beforeInitializingSession`, the `StateChangeHandler` simply puts `Expire` event on the event queue of the <<eventManager, ControllerEventManager>>

`startup` then puts `Startup` event at the end of the event queue of the <<eventManager, ControllerEventManager>> and immediately requests it to <<kafka-ControllerEventManager.adoc#start, start>>.

NOTE: `startup` is used exclusively when `KafkaServer` is requested to <<kafka-KafkaServer.adoc#startup, start>>.

=== [[registerSessionExpirationListener]] Registering SessionExpirationListener To Control Session Recreation -- `registerSessionExpirationListener` Internal Method

[source, scala]
----
registerSessionExpirationListener(): Unit
----

`registerSessionExpirationListener` requests <<zkUtils, ZkUtils>> to link:kafka-ZkUtils.adoc#subscribeStateChanges[subscribe to state changes] with a `SessionExpirationListener` (with the `KafkaController` and <<eventManager, ControllerEventManager>>).

NOTE: `SessionExpirationListener` puts <<Reelect, Reelect>> event on the link:kafka-ControllerEventManager.adoc#queue[event queue] of `ControllerEventManager` every time the Zookeeper session has expired and a new session has been created.

NOTE: `registerSessionExpirationListener` is used exclusively when <<Startup, Startup>> event is processed (after `ControllerEventThread` is link:kafka-ControllerEventThread.adoc#doWork[started]).

=== [[registerControllerChangeListener]] Registering ControllerChangeListener for /controller ZNode Changes -- `registerControllerChangeListener` Internal Method

[source, scala]
----
registerControllerChangeListener(): Unit
----

`registerControllerChangeListener` requests <<zkUtils, ZkUtils>> to link:kafka-ZkUtils.adoc#subscribeDataChanges[subscribe to data changes] for `/controller` znode with a `ControllerChangeListener` (with the `KafkaController` and <<eventManager, ControllerEventManager>>).

[NOTE]
====
`ControllerChangeListener` emits:

1. <<ControllerChange, ControllerChange>> event with the current controller ID (on the link:kafka-ControllerEventManager.adoc#queue[event queue] of `ControllerEventManager`) every time the data of a znode changes

1. <<Reelect, Reelect>> event when the data associated with a znode has been deleted
====

NOTE: `registerControllerChangeListener` is used exclusively when <<Startup, Startup>> event is processed (after `ControllerEventThread` is link:kafka-ControllerEventThread.adoc#doWork[started]).

=== [[registerBrokerChangeListener]] `registerBrokerChangeListener` Internal Method

[source, scala]
----
registerBrokerChangeListener(): Option[Seq[String]]
----

`registerBrokerChangeListener` requests <<zkUtils, ZkUtils>> to link:kafka-ZkUtils.adoc#subscribeChildChanges[subscribeChildChanges] for `/brokers/ids` path with <<brokerChangeListener, BrokerChangeListener>>.

NOTE: `registerBrokerChangeListener` is used exclusively when `KafkaController` does <<onControllerFailover, onControllerFailover>>.

=== [[getControllerID]] Getting Active Controller ID (from JSON under /controller znode) -- `getControllerID` Method

[source, scala]
----
getControllerID(): Int
----

`getControllerID` returns the ID of the active Kafka controller that is associated with `/controller` znode in JSON format or `-1` otherwise.

Internally, `getControllerID` requests <<zkUtils, ZkUtils>> for link:kafka-ZkUtils.adoc#readDataMaybeNull[data associated with `/controller` znode].

If available, `getControllerID` parses the data (being the current controller info in JSON format) to extract `brokerid` field.

[source, shell]
----
$ ./bin/zookeeper-shell.sh 0.0.0.0:2181
Connecting to 0.0.0.0:2181
Welcome to ZooKeeper!
...
get /controller
{"version":1,"brokerid":100,"timestamp":"1506197069724"}
cZxid = 0xf9
ctime = Sat Sep 23 22:04:29 CEST 2017
mZxid = 0xf9
mtime = Sat Sep 23 22:04:29 CEST 2017
pZxid = 0xf9
cversion = 0
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x15eaa3a4fdd000d
dataLength = 56
numChildren = 0
----

Otherwise, when no `/controller` znode is available, `getControllerID` returns `-1`.

[NOTE]
====
`getControllerID` is used when:

1. Processing `Reelect` controller event

1. <<elect, elect>>
====

=== [[registerTopicDeletionListener]] Registering TopicDeletionListener for Child Changes to /admin/delete_topics ZNode -- `registerTopicDeletionListener` Internal Method

[source, scala]
----
registerTopicDeletionListener(): Option[Seq[String]]
----

`registerTopicDeletionListener` requests <<zkUtils, ZkUtils>> to link:kafka-ZkUtils.adoc#subscribeChildChanges[subscribeChildChanges] to `/admin/delete_topics` znode with <<topicDeletionListener, TopicDeletionListener>>.

NOTE: `registerTopicDeletionListener` is used exclusively when `KafkaController` does <<onControllerFailover, onControllerFailover>>.

=== [[deregisterTopicDeletionListener]] De-Registering TopicDeletionListener for Child Changes to /admin/delete_topics ZNode -- `deregisterTopicDeletionListener` Internal Method

[source, scala]
----
deregisterTopicDeletionListener(): Unit
----

`deregisterTopicDeletionListener` requests <<zkUtils, ZkUtils>> to link:kafka-ZkUtils.adoc#unsubscribeChildChanges[unsubscribeChildChanges] to `/admin/delete_topics` znode with <<topicDeletionListener, TopicDeletionListener>>.

NOTE: `deregisterTopicDeletionListener` is used exclusively when `KafkaController` <<onControllerResignation, resigns as the active controller>>.

=== [[processUpdateNotifications]] `processUpdateNotifications` Internal Method

[source, scala]
----
processUpdateNotifications(partitions: Seq[TopicPartition]): Unit
----

`processUpdateNotifications`...FIXME

NOTE: `processUpdateNotifications` is used when...FIXME

=== [[onReplicasBecomeOffline]] `onReplicasBecomeOffline` Internal Method

[source, scala]
----
onReplicasBecomeOffline(newOfflineReplicas: Set[PartitionAndReplica]): Unit
----

`onReplicasBecomeOffline`...FIXME

NOTE: `onReplicasBecomeOffline` is used when...FIXME

=== [[onPartitionReassignment]] `onPartitionReassignment` Internal Method

[source, scala]
----
onPartitionReassignment(
  topicPartition: TopicPartition,
  reassignedPartitionContext: ReassignedPartitionsContext): Unit
----

`onPartitionReassignment`...FIXME

NOTE: `onPartitionReassignment` is used when...FIXME

=== [[onBrokerUpdate]] `onBrokerUpdate` Internal Method

[source, scala]
----
onBrokerUpdate(updatedBrokerId: Int): Unit
----

`onBrokerUpdate`...FIXME

NOTE: `onBrokerUpdate` is used when...FIXME

=== [[updateBrokerInfo]] `updateBrokerInfo` Internal Method

[source, scala]
----
updateBrokerInfo(newBrokerInfo: BrokerInfo): Unit
----

`updateBrokerInfo`...FIXME

NOTE: `updateBrokerInfo` is used exclusively when `DynamicListenerConfig` is requested to <<kafka-server-DynamicListenerConfig.adoc#reconfigure, reconfigure>>.

=== [[registerBrokerModificationsHandler]] `registerBrokerModificationsHandler` Internal Method

[source, scala]
----
registerBrokerModificationsHandler(brokerIds: Iterable[Int]): Unit
----

`registerBrokerModificationsHandler`...FIXME

NOTE: `registerBrokerModificationsHandler` is used when `KafkaController` is requested to <<onBrokerStartup, onBrokerStartup>> and <<onControllerFailover, onControllerFailover>> (indirectly through <<initializeControllerContext, initializeControllerContext>>).

=== [[initializeControllerContext]] `initializeControllerContext` Internal Method

[source, scala]
----
initializeControllerContext(): Unit
----

`initializeControllerContext`...FIXME

NOTE: `initializeControllerContext` is used exclusively when `KafkaController` is requested to <<onControllerFailover, onControllerFailover>>.

=== [[unregisterBrokerModificationsHandler]] `unregisterBrokerModificationsHandler` Internal Method

[source, scala]
----
unregisterBrokerModificationsHandler(brokerIds: Iterable[Int]): Unit
----

`unregisterBrokerModificationsHandler`...FIXME

NOTE: `unregisterBrokerModificationsHandler` is used when `KafkaController` is requested to <<onControllerResignation, onControllerResignation>> and <<onBrokerFailure, onBrokerFailure>>.

=== [[onBrokerFailure]] `onBrokerFailure` Internal Method

[source, scala]
----
onBrokerFailure(deadBrokers: Seq[Int]): Unit
----

`onBrokerFailure`...FIXME

NOTE: `onBrokerFailure` is used exclusively when `KafkaController` is requested to handle a <<BrokerChange, BrokerChange>> controller event.

=== [[maybeTriggerPartitionReassignment]] `maybeTriggerPartitionReassignment` Internal Method

[source, scala]
----
maybeTriggerPartitionReassignment(topicPartitions: Set[TopicPartition]): Unit
----

`maybeTriggerPartitionReassignment`...FIXME

NOTE: `maybeTriggerPartitionReassignment` is used when `KafkaController` is requested to <<onControllerFailover, onControllerFailover>> and process the <<PartitionReassignment, PartitionReassignment>> controller event.

=== [[incrementControllerEpoch]] `incrementControllerEpoch` Internal Method

[source, scala]
----
incrementControllerEpoch(): Unit
----

`incrementControllerEpoch`...FIXME

NOTE: `incrementControllerEpoch` is used exclusively when `KafkaController` is requested to <<onControllerFailover, onControllerFailover>>.

=== [[fetchPendingPreferredReplicaElections]] `fetchPendingPreferredReplicaElections` Internal Method

[source, scala]
----
fetchPendingPreferredReplicaElections(): Set[TopicPartition]
----

`fetchPendingPreferredReplicaElections`...FIXME

NOTE: `fetchPendingPreferredReplicaElections` is used exclusively when `KafkaController` is requested to <<onControllerFailover, onControllerFailover>>.

=== [[initializePartitionReassignment]] `initializePartitionReassignment` Internal Method

[source, scala]
----
initializePartitionReassignment(): Unit
----

`initializePartitionReassignment`...FIXME

NOTE: `initializePartitionReassignment` is used exclusively when `KafkaController` is requested to <<initializeControllerContext, initializeControllerContext>>.

=== [[fetchTopicDeletionsInProgress]] `fetchTopicDeletionsInProgress` Internal Method

[source, scala]
----
fetchTopicDeletionsInProgress(): (Set[String], Set[String])
----

`fetchTopicDeletionsInProgress`...FIXME

NOTE: `fetchTopicDeletionsInProgress` is used exclusively when `KafkaController` is requested to <<onControllerFailover, onControllerFailover>>.

=== [[updateLeaderAndIsrCache]] `updateLeaderAndIsrCache` Internal Method

[source, scala]
----
updateLeaderAndIsrCache(partitions: Seq[TopicPartition]
----

`updateLeaderAndIsrCache`...FIXME

NOTE: `updateLeaderAndIsrCache` is used when `KafkaController` is requested to <<initializeControllerContext, initializeControllerContext>> and process a <<IsrChangeNotification, IsrChangeNotification>> controller event.

=== [[areReplicasInIsr]] `areReplicasInIsr` Internal Method

[source, scala]
----
areReplicasInIsr(partition: TopicPartition, replicas: Seq[Int]): Boolean
----

`areReplicasInIsr`...FIXME

NOTE: `areReplicasInIsr` is used exclusively when `KafkaController` is requested to <<onPartitionReassignment, onPartitionReassignment>>.

=== [[updateAssignedReplicasForPartition]] `updateAssignedReplicasForPartition` Internal Method

[source, scala]
----
updateAssignedReplicasForPartition(
  partition: TopicPartition,
  replicas: Seq[Int]): Unit
----

`updateAssignedReplicasForPartition`...FIXME

NOTE: `updateAssignedReplicasForPartition` is used exclusively when `KafkaController` is requested to <<onPartitionReassignment, onPartitionReassignment>>.

=== [[registerPartitionModificationsHandlers]] `registerPartitionModificationsHandlers` Internal Method

[source, scala]
----
registerPartitionModificationsHandlers(topics: Seq[String]): Unit
----

`registerPartitionModificationsHandlers`...FIXME

NOTE: `registerPartitionModificationsHandlers` is used when `KafkaController` is requested to <<initializeControllerContext, initializeControllerContext>> and process a <<TopicChange, TopicChange>> controller event.

=== [[unregisterPartitionModificationsHandlers]] `unregisterPartitionModificationsHandlers` Internal Method

[source, scala]
----
unregisterPartitionModificationsHandlers(topics: Seq[String]): Unit
----

`unregisterPartitionModificationsHandlers`...FIXME

[NOTE]
====
`unregisterPartitionModificationsHandlers` is used when:

* `KafkaController` is requested to <<onControllerResignation, onControllerResignation>>

* `TopicDeletionManager` is requested to <<kafka-TopicDeletionManager.adoc#completeDeleteTopic, completeDeleteTopic>>
====

=== [[registerPartitionModificationsHandlers]] `registerPartitionModificationsHandlers` Internal Method

[source, scala]
----
registerPartitionModificationsHandlers(topics: Seq[String]): Unit
----

`registerPartitionModificationsHandlers`...FIXME

NOTE: `registerPartitionModificationsHandlers` is used when `KafkaController` is requested to <<initializeControllerContext, initializeControllerContext>> and process a <<TopicChange, TopicChange>> controller event.

=== [[unregisterPartitionReassignmentIsrChangeHandlers]] `unregisterPartitionReassignmentIsrChangeHandlers` Internal Method

[source, scala]
----
unregisterPartitionReassignmentIsrChangeHandlers(): Unit
----

`unregisterPartitionReassignmentIsrChangeHandlers`...FIXME

NOTE: `unregisterPartitionReassignmentIsrChangeHandlers` is used exclusively when `KafkaController` is requested to <<onControllerResignation, onControllerResignation>>.

=== [[readControllerEpochFromZooKeeper]] `readControllerEpochFromZooKeeper` Internal Method

[source, scala]
----
readControllerEpochFromZooKeeper(): Unit
----

`readControllerEpochFromZooKeeper`...FIXME

NOTE: `readControllerEpochFromZooKeeper` is used exclusively when `KafkaController` is requested to <<onControllerFailover, onControllerFailover>>.

=== [[removePartitionsFromReassignedPartitions]] `removePartitionsFromReassignedPartitions` Internal Method

[source, scala]
----
removePartitionsFromReassignedPartitions(partitionsToBeRemoved: Set[TopicPartition]): Unit
----

`removePartitionsFromReassignedPartitions`...FIXME

NOTE: `removePartitionsFromReassignedPartitions` is used when `KafkaController` is requested to <<onPartitionReassignment, onPartitionReassignment>> and <<maybeTriggerPartitionReassignment, maybeTriggerPartitionReassignment>>.

=== [[removePartitionsFromPreferredReplicaElection]] `removePartitionsFromPreferredReplicaElection` Internal Method

[source, scala]
----
removePartitionsFromPreferredReplicaElection(
  partitionsToBeRemoved: Set[TopicPartition],
  isTriggeredByAutoRebalance : Boolean): Unit
----

`removePartitionsFromPreferredReplicaElection`...FIXME

NOTE: `removePartitionsFromPreferredReplicaElection` is used exclusively when `KafkaController` is requested to <<onPreferredReplicaElection, onPreferredReplicaElection>>.

=== [[onPreferredReplicaElection]] `onPreferredReplicaElection` Internal Method

[source, scala]
----
onPreferredReplicaElection(
  partitions: Set[TopicPartition],
  isTriggeredByAutoRebalance: Boolean = false): Unit
----

`onPreferredReplicaElection`...FIXME

NOTE: `onPreferredReplicaElection` is used when `KafkaController` is requested to <<onControllerFailover, onControllerFailover>>, <<checkAndTriggerAutoLeaderRebalance, checkAndTriggerAutoLeaderRebalance>> and process a <<PreferredReplicaLeaderElection, PreferredReplicaLeaderElection>> controller event.

=== [[updateLeaderEpoch]] `updateLeaderEpoch` Internal Method

[source, scala]
----
updateLeaderEpoch(partition: TopicPartition): Option[LeaderIsrAndControllerEpoch]
----

`updateLeaderEpoch`...FIXME

NOTE: `updateLeaderEpoch` is used exclusively  when `KafkaController` is requested to <<updateLeaderEpochAndSendRequest, updateLeaderEpochAndSendRequest>>.

=== [[moveReassignedPartitionLeaderIfRequired]] `moveReassignedPartitionLeaderIfRequired` Internal Method

[source, scala]
----
moveReassignedPartitionLeaderIfRequired(
  topicPartition: TopicPartition,
  reassignedPartitionContext: ReassignedPartitionsContext): Unit
----

`moveReassignedPartitionLeaderIfRequired`...FIXME

NOTE: `moveReassignedPartitionLeaderIfRequired` is used exclusively  when `KafkaController` is requested to <<onPartitionReassignment, onPartitionReassignment>>.

=== [[onControllerFailover]] `onControllerFailover` Internal Method

[source, scala]
----
onControllerFailover(): Unit
----

`onControllerFailover`...FIXME

With <<kafka-properties.adoc#auto.leader.rebalance.enable, auto.leader.rebalance.enable>> on, `onControllerFailover` <<scheduleAutoLeaderRebalanceTask, scheduleAutoLeaderRebalanceTask>> with the delay of 5 seconds.

`onControllerFailover`...FIXME

NOTE: `onControllerFailover` is used exclusively when `KafkaController` is requested to <<elect, elect>>.

=== [[scheduleAutoLeaderRebalanceTask]] `scheduleAutoLeaderRebalanceTask` Internal Method

[source, scala]
----
scheduleAutoLeaderRebalanceTask(delay: Long, unit: TimeUnit): Unit
----

`scheduleAutoLeaderRebalanceTask` simply requests the <<kafkaScheduler, KafkaScheduler>> to <<kafka-KafkaScheduler.adoc#schedule, schedule a one-off task>> called *auto-leader-rebalance-task* with initial delay of 5 seconds.

The `auto-leader-rebalance-task` simply requests the <<eventManager, ControllerEventManager>> to <<kafka-ControllerEventManager.adoc#put, enqueue a AutoPreferredReplicaLeaderElection event>>.

[NOTE]
====
`scheduleAutoLeaderRebalanceTask` is used when:

* `KafkaController` is requested to <<onControllerFailover, onControllerFailover>>

* `ControllerEventThread` is requested to process a <<kafka-ControllerEvent.adoc#AutoPreferredReplicaLeaderElection, AutoPreferredReplicaLeaderElection>> event (while <<kafka-ControllerEventThread.adoc#doWork, processing controller events>>).
====

=== [[checkAndTriggerAutoLeaderRebalance]] `checkAndTriggerAutoLeaderRebalance` Internal Method

[source, scala]
----
checkAndTriggerAutoLeaderRebalance(): Unit
----

`checkAndTriggerAutoLeaderRebalance` prints out the following TRACE message to the logs:

```
Checking need to trigger auto leader balancing
```

NOTE: `checkAndTriggerAutoLeaderRebalance` is used exclusively when `ControllerEventThread` is requested to process a <<kafka-ControllerEvent.adoc#AutoPreferredReplicaLeaderElection, AutoPreferredReplicaLeaderElection>> event (while <<kafka-ControllerEventThread.adoc#doWork, processing controller events>>).
