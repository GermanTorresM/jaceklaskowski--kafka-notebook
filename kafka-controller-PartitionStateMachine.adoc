== [[PartitionStateMachine]] PartitionStateMachine

`PartitionStateMachine` is <<creating-instance, created>> exclusively for <<kafka-controller-KafkaController.adoc#partitionStateMachine, KafkaController>>.

`PartitionStateMachine` is <<startup, started>> when `KafkaController` is requested to <<kafka-controller-KafkaController.adoc#onControllerFailover, onControllerFailover>> (when `KafkaController` is requested for <<elect, controller election>> and a broker is successfully elected as the controller).

`PartitionStateMachine` is <<shutdown, shut down>> when `KafkaController` is requested to <<kafka-controller-KafkaController.adoc#onControllerResignation, resign as the active controller>>.

[[PartitionLeaderElectionStrategy]]
`PartitionStateMachine` uses a `PartitionLeaderElectionStrategy` when <<handleStateChanges, handleStateChanges>> (with <<doHandleStateChanges, doHandleStateChanges>>) and <<electLeaderForPartitions, electLeaderForPartitions>> (with <<doElectLeaderForPartitions, doElectLeaderForPartitions>>):

* [[ControlledShutdownPartitionLeaderElectionStrategy]] `ControlledShutdownPartitionLeaderElectionStrategy`
* [[OfflinePartitionLeaderElectionStrategy]] `OfflinePartitionLeaderElectionStrategy`
* [[PreferredReplicaPartitionLeaderElectionStrategy]] `PreferredReplicaPartitionLeaderElectionStrategy`
* [[ReassignPartitionLeaderElectionStrategy]] `ReassignPartitionLeaderElectionStrategy`

[[internal-registries]]
.PartitionStateMachine's Internal Properties (e.g. Registries, Counters and Flags)
[cols="1m,2",options="header",width="100%"]
|===
| Name
| Description

| controllerId
| [[controllerId]]

| topicDeletionManager
| [[topicDeletionManager]][[setTopicDeletionManager]] <<kafka-controller-TopicDeletionManager.adoc#, TopicDeletionManager>>

| offlinePartitionCount
| [[offlinePartitionCount]]
|===

[[logIdent]]
`PartitionStateMachine` uses *[PartitionStateMachine controllerId=[controllerId]]* as the logging prefix (aka `logIdent`).

[[logging]]
[TIP]
====
Enable `INFO` or `ERROR` logging levels for `kafka.controller.PartitionStateMachine` logger to see what happens inside.

Add the following line to `config/log4j.properties`:

```
log4j.logger.kafka.controller.PartitionStateMachine=INFO
```

Refer to link:kafka-logging.adoc[Logging].

---

Please note that Kafka comes with a preconfigured `kafka.controller` logger in `config/log4j.properties`:

```
log4j.appender.controllerAppender=org.apache.log4j.DailyRollingFileAppender
log4j.appender.controllerAppender.DatePattern='.'yyyy-MM-dd-HH
log4j.appender.controllerAppender.File=${kafka.logs.dir}/controller.log
log4j.appender.controllerAppender.layout=org.apache.log4j.PatternLayout
log4j.appender.controllerAppender.layout.ConversionPattern=[%d] %p %m (%c)%n

log4j.logger.kafka.controller=TRACE, controllerAppender
log4j.additivity.kafka.controller=false
```

That means that the logs of `PartitionStateMachine` go to `logs/controller.log` file at `TRACE` logging level and are not added to the main logs (per `log4j.additivity` being off).
====

=== [[triggerOnlinePartitionStateChange]] `triggerOnlinePartitionStateChange` Method

[source, scala]
----
triggerOnlinePartitionStateChange(): Unit // <1>
triggerOnlinePartitionStateChange(topic: String): Unit  // <2>
triggerOnlinePartitionStateChange(partitionState: Map[TopicPartition, PartitionState]): Unit
----
<1> Uses the <<partitionState, partitionState>> for the input `partitionState`
<2> Takes `TopicPartitions` from the <<partitionState, partitionState>> that match the input `topic` for the input `partitionState`

`triggerOnlinePartitionStateChange` collects the `TopicPartitions` (from the given `PartitionState` per `TopicPartition` collection) that meet the following requirements:

. <<topicDeletionManager, TopicDeletionManager>> is not going to <<kafka-controller-TopicDeletionManager.adoc#isTopicQueuedUpForDeletion, delete their topics>>

. `PartitionState` is neither `OfflinePartition` nor `NewPartition`

`triggerOnlinePartitionStateChange` <<handleStateChanges, handleStateChanges>> for the partitions with `OnlinePartition` target state and the `OfflinePartitionLeaderElectionStrategy`.

[NOTE]
====
`triggerOnlinePartitionStateChange` is used when:

* `KafkaController` is requested to <<kafka-controller-KafkaController.adoc#onBrokerStartup, onBrokerStartup>>, <<kafka-controller-KafkaController.adoc#onReplicasBecomeOffline, onReplicasBecomeOffline>>, and at <<kafka-controller-ControllerEvent.adoc#UncleanLeaderElectionEnable, UncleanLeaderElectionEnable>> and <<kafka-controller-ControllerEvent.adoc#TopicUncleanLeaderElectionEnable, TopicUncleanLeaderElectionEnable>> controller events

* `PartitionStateMachine` is requested to <<startup, startup>>
====

=== [[handleStateChanges]] `handleStateChanges` Method

[source, scala]
----
handleStateChanges(
  partitions: Set[TopicAndPartition],
  targetState: PartitionState,
  leaderSelector: PartitionLeaderSelector = noOpPartitionLeaderS...,
  callbacks: Callbacks): Unit
----

`handleStateChanges`...FIXME

NOTE: `handleStateChanges` is used when...FIXME

=== [[shutdown]] `shutdown` Method

[source, scala]
----
shutdown(): Unit
----

`shutdown`...FIXME

NOTE: `shutdown` is used when...FIXME

=== [[startup]] Starting Up (On Active Controller) -- `startup` Method

[source, scala]
----
startup(): Unit
----

`startup` prints out the following INFO message to the logs:

```
Initializing partition state
```

`startup` <<initializePartitionState, initializePartitionState>>.

`startup` prints out the following INFO message to the logs:

```
Triggering online partition state changes
```

`startup` <<triggerOnlinePartitionStateChange, triggerOnlinePartitionStateChange>>.

In the end, `startup` prints out the following INFO message to the logs:

```
Started partition state machine with initial state -> [partitionState]
```

NOTE: `startup` is used exclusively when `KafkaController` is requested to <<kafka-controller-KafkaController.adoc#onControllerFailover, onControllerFailover>> (when `KafkaController` is requested to <<elect, elect>> and a broker is successfully elected as the controller).

=== [[doElectLeaderForPartitions]] `doElectLeaderForPartitions` Internal Method

[source, scala]
----
doElectLeaderForPartitions(
  partitions: Seq[TopicPartition],
  partitionLeaderElectionStrategy: PartitionLeaderElectionStrategy)
: (Seq[TopicPartition], Seq[TopicPartition], Map[TopicPartition, Exception])
----

`doElectLeaderForPartitions`...FIXME

NOTE: `doElectLeaderForPartitions` is used when...FIXME

=== [[creating-instance]] Creating PartitionStateMachine Instance

`PartitionStateMachine` takes the following when created:

* [[config]] <<kafka-KafkaConfig.adoc#, KafkaConfig>>
* [[stateChangeLogger]] `StateChangeLogger`
* [[controllerContext]] <<kafka-controller-ControllerContext.adoc#, ControllerContext>>
* [[zkClient]] <<kafka-zk-KafkaZkClient.adoc#, KafkaZkClient>>
* [[partitionState]] `TopicPartitions` and their `PartitionState` (`mutable.Map[TopicPartition, PartitionState]`)
* [[controllerBrokerRequestBatch]] <<kafka-controller-ControllerBrokerRequestBatch.adoc#, ControllerBrokerRequestBatch>>

`PartitionStateMachine` initializes the <<internal-registries, internal registries and counters>>.

=== [[electLeaderForPartitions]] `electLeaderForPartitions` Internal Method

[source, scala]
----
electLeaderForPartitions(
  partitions: Seq[TopicPartition],
  partitionLeaderElectionStrategy: PartitionLeaderElectionStrategy): Seq[TopicPartition]
----

`electLeaderForPartitions`...FIXME

NOTE: `electLeaderForPartitions` is used when...FIXME

=== [[doHandleStateChanges]] `doHandleStateChanges` Internal Method

[source, scala]
----
doHandleStateChanges(
  partitions: Seq[TopicPartition],
  targetState: PartitionState,
  partitionLeaderElectionStrategyOpt: Option[PartitionLeaderElectionStrategy]): Unit
----

`doHandleStateChanges`...FIXME

NOTE: `doHandleStateChanges` is used when...FIXME

=== [[initializePartitionState]] `initializePartitionState` Internal Method

[source, scala]
----
initializePartitionState(): Unit
----

`initializePartitionState` requests the <<controllerContext, ControllerContext>> for <<kafka-controller-ControllerContext.adoc#allPartitions, all partitions>> (in the Kafka cluster).

For every `TopicPartition`, `initializePartitionState` requests the <<controllerContext, ControllerContext>> for the `LeaderIsrAndControllerEpoch` (using the <<kafka-controller-ControllerContext.adoc#partitionLeadershipInfo, partitionLeadershipInfo>> registry).

`initializePartitionState` <<changeStateTo, changeStateTo>> of the `TopicPartition` as follows:

* `OnlinePartition`...FIXME
* `OfflinePartition`...FIXME
* `NewPartition`...FIXME

NOTE: `initializePartitionState` is used exclusively when `PartitionStateMachine` is requested to <<startup, start up on the active Controller>>.

=== [[changeStateTo]] `changeStateTo` Internal Method

[source, scala]
----
changeStateTo(
  partition: TopicPartition,
  currentState: PartitionState,
  targetState: PartitionState): Unit
----

`changeStateTo`...FIXME

NOTE: `changeStateTo` is used when...FIXME
